#!/usr/bin/env bash
#
# hhhconf - a config tool for tint2
#
# shellcheck disable=2154 source=/dev/null

die () {
	printf '\033[31mfatal:\033[m %b\n' "$@" >&2
	exit 1
}

log () {
	printf '\033[32m=>\033[m %s\n' "$@"
}

read_sleep () {
	read -rst "${1:-1}" -N 999
	return 0
}

backup () {
	local files_to_backup="${HOME}/.config/tint2/tint2rc"
	local backup_dir
	backup_dir="${HOME}/.cache/hhhconf/backup/$(date +%Y%m%d%H%M%S%N)"
	test -d "${backup_dir}" && die "duplicate backup directory"
	mkdir -p "${backup_dir}"
	log "backup to $backup_dir"
	for f in ${files_to_backup}
	do
		test -e "${f}" || continue
		cp -p "${f}" "${backup_dir}"
	done
}

apply_gtk_font_to_tint2 () {
	backup
	local font=$(hhhconf-gtkfont)
	hhhconf-t2 -p "task_font" "$font"
	hhhconf-t2 -p "taskbar_name_font" "$font"
	hhhconf-t2 -p "time1_font" "$font"
	hhhconf-t2 -p "time2_font" "$font"
	hhhconf-t2 -p "tooltip_font" "$font"
	hhhconf-t2 -p "bat1_font" "$font"
	hhhconf-t2 -p "bat2_font" "$font"
	# Need more sophisticated code to add 'execp_font' and 'button_font'
}

pywal_tint2 () {
	backup
	local wal_colours="${HOME}/.cache/wal/colors.sh"
	[[ -e $wal_colours ]] || die "cannot find $wal_colours"
	. "$wal_colours"
#	hhhconf-t2 -s panel background_color "$background 100"
	hhhconf-t2 -s task_active background_color "$color1 100"
	hhhconf-t2 task_background_id 0
}

hard_restart () {
	log "restart $1"
	killall "$1" ; nohup "$1" >/dev/null 2>&1 &
	disown
}

print_commands () {
	printf "%b" "\
f = apply gtk3 font to tint2\n\
h = show available commands\n\
i = import tint2rc\n\
p = apply pywal to tint2\n\
t = tint2 restart soft\n\
T = tint2 restart hard\n\
- = sleep one second\n\
q = quit\n"
}

bad_command () {
	log "($1) is not a recognised command"
}

process_command_string () {
	# process one character at a time
	for ((i=0;i<${#1};i++)); do
		case "${1:$i:1}" in
			f) apply_gtk_font_to_tint2 ;;
			i) backup ; hhhconf-import ;;
			t) killall -SIGUSR2 tint2 ;;
			T) hard_restart tint2 ;;
			p) pywal_tint2 ;;
			h|\?) print_commands ;;
			q) return 1 ;;
			-) read_sleep 1 ;;
			'') ;;
			*) bad_command "$1" ;;
		esac
	done
}

prompt () {
	local cmd=
	printf "%b" "\033[32mWhat now>\033[m "
	read -r cmd
	process_command_string "$cmd"
}

await_user_command () {
	print_commands
	while :
	do
		prompt || break
	done
}

usage () {
	printf "%b\n" "usage: hhhconf [-h] [<commands>]"
	exit 0
}

args() {
	case $1 in
		-h)	usage ;;
		*)	process_command_string "$1" ;;
	esac
}

main() {
	if [[ $# -gt 0 ]]; then
		args "$@"
	else
		await_user_command
	fi
}

main "$@"
